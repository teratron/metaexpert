# Спецификация системы логирования для MetaExpert

**ID:** `SPEC-LOGGING`
**Статус:** Утверждено
**Версия:** 1.0
**Дата:** 2025-10-16

---

## 1. Обзор

Этот документ определяет полную спецификацию для модуля логирования (`logger`) проекта `MetaExpert`. Система логирования является критически важным компонентом для отладки, мониторинга и анализа работы торговых экспертов.

Спецификация основана на использовании библиотеки `structlog` для обеспечения структурированного, расширяемого и высокопроизводительного логирования.

### 1.1. Цели системы логирования

- **Информативность:** Логи должны содержать достаточно контекста для полного понимания произошедших событий.
- **Структурированность:** Поддержка вывода в формате JSON для упрощения автоматизированной обработки и анализа логов (например, в ELK Stack, Datadog, Splunk).
- **Производительность:** Минимальное влияние на производительность основного приложения, особенно в live-trading режиме.
- **Гибкость:** Возможность легкой настройки уровней, форматов и обработчиков (handlers) логов.
- **Разделение потоков:** Разделение общих логов, торговых операций и ошибок по разным файлам.

---

## 2. Основные принципы проектирования

- **Библиотека-первичность:** Конфигурация и использование логгера должны быть доступны как через API библиотеки, так и через CLI.
- **Контекстуализация:** `structlog` будет использоваться для автоматического добавления контекста к лог-сообщениям (например, `expert_name`, `trade_id`, `order_id`).
- **Асинхронная поддержка:** Система должна быть совместима с асинхронным кодом (`asyncio`) и поддерживать асинхронную запись в файлы для минимизации блокировок.
- **Отказоустойчивость:** Ошибки в самой системе логирования не должны приводить к падению основного приложения. При сбоях (например, невозможность записи в файл) система должна пытаться записать ошибку в резервный поток (например, stderr) и, при необходимости, переключаться на более простой режим работы (например, с асинхронного на синхронный). Все ошибки самого логгера должны попадать в отдельный файл `logging_errors.log`.

---

## 3. Архитектура модуля логирования

### 3.1. Файловая структура модуля

```
src/metaexpert/
└── logger/
    ├── __init__.py          # Фабрика MetaLogger
    ├── config.py            # Pydantic-модели для конфигурации
    ├── processors.py        # Цепочка процессоров structlog
    ├── formatters.py        # Форматтеры для консоли и JSON
    ├── handlers/
    │   ├── __init__.py
    │   ├── file.py          # Ротируемые и асинхронные файловые обработчики
    │   ├── telegram.py      # Обработчик для алертов в Telegram/Discord
    │   └── stderr.py        # Резервный обработчик для stderr
    └── context.py           # Утилиты для управления контекстом логирования
```

### 3.2. Основные компоненты

- **`MetaLogger` (фабрика):** Основная функция в `logger/__init__.py`, отвечающая за конфигурацию `structlog` и возвращающая готовый к использованию логгер.
- **Модели `Pydantic`:** В `logger/config.py` будут определены модели для декларативной конфигурации. Для удобства будут использоваться алиасы, чтобы переменные окружения могли быть короткими (например, `LOG_LEVEL`, а не `METAEXPERT_LOG_LEVEL`).
- **Цепочка процессоров `structlog`:** В `logger/processors.py` будет определена и использована стандартная цепочка процессоров, включающая:
  - `structlog.contextvars.merge_contextvars`: для интеграции с `contextvars`.
  - `structlog.processors.add_log_level`: добавление уровня лога.
  - `structlog.processors.StackInfoRenderer`: рендеринг стектрейса.
  - `structlog.dev.set_exc_info`: добавление информации об исключениях.
  - `structlog.processors.TimeStamper`: добавление временной метки (в формате ISO 8601 UTC).
  - Кастомные процессоры для добавления доменного контекста (`add_expert_context`, `add_trade_details`).
  - `structlog.processors.JSONRenderer`: финальный рендеринг в JSON (для файлов).
  - `structlog.dev.ConsoleRenderer`: цветной рендеринг для консоли.
- **Форматтеры:** В `logger/formatters.py` будет реализована фабрика `get_formatter(fmt: str)`, возвращающая нужный рендерер (`JSONRenderer` или `ConsoleRenderer`), что позволит легко переключать формат вывода.
- **Обработчики (Handlers):** В `logger/handlers/` будут реализованы обработчики, включая асинхронный файловый обработчик с буферизацией через `asyncio.Queue` для минимизации блокировок в live-режиме.

### 3.3. Конфигурация

Конфигурация логирования будет управляться через `Pydantic`-модель и может быть переопределена на разных уровнях (приоритет по убыванию):

1. **Опции CLI:** Параметры, переданные при запуске через командную строку (например, `metaexpert run --log-level DEBUG`), имеют наивысший приоритет.
2. **Конструктор `MetaExpert`:** Параметры, явно указанные при создании экземпляра `expert` в файле стратегии (как в `template.py`), например, `expert = MetaExpert(log_level="INFO", ...)`.
3. **Переменные окружения:** Значения из `.env` файла или системных переменных (например, `METAEXPERT_LOG_LEVEL=WARNING`).
4. **Глобальная конфигурация:** Настройки из `pyproject.toml` (если будут реализованы).
5. **Значения по умолчанию:** Встроенные значения по умолчанию в коде библиотеки.

---

## 4. Функциональные требования

### 4.1. Уровни логирования

Система поддерживает стандартные уровни: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`.

- **`DEBUG`:** Подробная информация для отладки (например, содержимое API-запросов/ответов).
- **`INFO`:** Ключевые события жизненного цикла эксперта (старт, стоп, открытие/закрытие позиции).
- **`WARNING`:** Нештатные, но не критичные ситуации (например, большое проскальзывание, временная потеря соединения).
- **`ERROR`:** Ошибки, которые привели к сбою выполнения конкретной операции, но не всего приложения (например, не удалось разместить ордер).
- **`CRITICAL`:** Ошибки, приводящие к аварийному завершению работы эксперта.
- **`TRADE`:** Специализированный уровень для логирования исключительно торговых событий. Вместо кастомного уровня будет использоваться подход с `binder` из `structlog`: `trade_logger = logger.bind(category="trade")`. Это позволит фильтровать сообщения на уровне обработчика и направлять их в `trades.log`, не создавая новый уровень логов.

### 4.2. Форматы вывода

#### 4.2.1. Текстовый формат (для консоли)

Оптимизирован для человеческого восприятия, с цветовым выделением уровней.

```
2025-10-16 10:30:00 [INFO     ] Expert started     expert_name=MyEmaBot symbol=BTCUSDT
2025-10-16 10:31:00 [INFO     ] Position opened    action=BUY size=0.1 price=70000.0 order_id=123
2025-10-16 10:32:00 [ERROR    ] Order failed       reason="Insufficient funds" order_id=124
```

#### 4.2.2. JSON формат (для файлов и внешних систем)

Каждая запись — это отдельный JSON-объект, содержащий максимум контекста.

```json
{"event": "Position opened", "level": "info", "timestamp": "2025-10-16T10:31:00Z", "expert_name": "MyEmaBot", "symbol": "BTCUSDT", "action": "BUY", "size": 0.1, "price": 70000.0, "order_id": 123}
{"event": "Order failed", "level": "error", "timestamp": "2025-10-16T10:32:00Z", "expert_name": "MyEmaBot", "reason": "Insufficient funds", "order_id": 124}
```

### 4.3. Разделение лог-файлов

- **`expert.log`:** Основной лог-файл. Содержит все сообщения от `INFO` и выше.
- **`trades.log`:** Специализированный лог только для торговых операций (создание/исполнение/отмена ордеров, открытие/закрытие позиций). Записывается в формате **JSON Lines (JSONL)**, где каждая строка является валидным JSON-объектом.
- **`errors.log`:** Содержит только сообщения уровня `ERROR` и `CRITICAL` с полным стектрейсом.

### 4.4. Ротация логов

Для всех лог-файлов должна быть настроена автоматическая ротация по размеру (`RotatingFileHandler`).

- Максимальный размер файла: 10 MB (настраивается).
- Количество бэкап-файлов: 5 (настраивается).

### 4.5. Контекстуализация

`structlog` позволяет привязывать контекст к логгеру.

```python
# Привязка контекста на уровне эксперта
log = logger.bind(expert_name="MyEmaBot", symbol="BTCUSDT")

# Внутри торговой логики можно добавлять временный контекст
log.info("Processing order", order_id=order.id)
```

---

## 5. API и использование

### 5.1. Инициализация в `MetaExpert`

Логгер инициализируется внутри `MetaExpert.__init__` и доступен через `self.logger`.

```python
class MetaExpert:
    def __init__(self, log_level: str = "INFO", structured_logging: bool = False, ...):
        self.logger = MetaLogger(
            log_level=log_level,
            structured_logging=structured_logging,
            ...
        )
        self.logger.info("Expert initialized")
```

### 5.2. Использование в коде стратегии

Пользователь получает доступ к логгеру через экземпляр `expert`.

```python
@expert.on_bar
def my_strategy(rates):
    expert.logger.info("New bar received", open=rates.open, close=rates.close)
    if some_condition:
        expert.logger.warning("High volatility detected", volatility=0.5)

# Логирование торговой операции
trade_logger = expert.logger.bind(category="trade")
trade_logger.info("Position opened", side="BUY", size=0.1, price=70000.0)
```

---

## 6. Тестирование

- Модуль `logger` должен быть покрыт unit-тестами.
- Тесты должны проверять:
  - Корректность конфигурации логгера с разными параметрами.
  - Правильность форматов вывода (текстовый и JSON).
  - Корректность работы кастомных процессоров.
  - Правильное разделение записей по разным файлам (`trades.log`, `errors.log`).
- **End-to-End тест:** Должен быть реализован как минимум один E2E-тест, который:
    1. Запускает тестового эксперта, который генерирует записи логов всех уровней.
    2. Проверяет, что лог-файлы (`expert.log`, `trades.log`, `errors.log`) были созданы.
    3. Читает записи из JSONL-файлов и валидирует их структуру на соответствие предопределенной `jsonschema`.
- Покрытие кода тестами для модуля `logger` должно быть не менее 95%.

---

## 7. Документация

- Создать файл `docs/guides/logging.md`, описывающий:
  - Как настраивать логирование.
  - Разницу между форматами вывода.
  - Назначение разных лог-файлов.
  - Примеры добавления контекста в логи.
  - Таблицу с примерами сообщений для каждого уровня логирования:

    | Уровень | Пример           | Назначение        |
    | ------- | ---------------- | ----------------- |
    | `DEBUG` | `API request sent` | Отладочная информация о запросах |
    | `INFO`  | `Expert started` | Ключевые события жизненного цикла     |
    | `WARNING`| `High slippage detected`| Нештатные, но не критичные ситуации |
    | `TRADE` | `Order executed` | События, связанные с торговлей    |
    | `ERROR` | `Order failed`   | Ошибка исполнения конкретной операции |
    | `CRITICAL`|`API key invalid` | Ошибка, останавливающая работу эксперта |

- Обновить `README.md`.

---

## 8. Интеграция и улучшения

### 8.1. Интеграция с системами мониторинга

Для интеграции с системами вроде Prometheus или Datadog будет предусмотрен интерфейс-адаптер. Это позволит "оборачивать" основной логгер и дублировать ключевые события (например, сделки) в виде метрик.

```python
# Пример в metrics/logger_adapter.py
class PrometheusLoggerAdapter:
    def __init__(self, logger):
        self.logger = logger
        # self.trade_counter = Counter(...)

    def info(self, event, **kwargs):
        if kwargs.get("category") == "trade":
            # self.trade_counter.inc()
            pass
        self.logger.info(event, **kwargs)
```

### 8.2. Асинхронная буферизация

В высокопроизводительных режимах будет использоваться асинхронный файловый обработчик (`handlers/file.py`) с `asyncio.Queue` для буферизации логов. Это предотвратит блокировку основного потока приложения операциями ввода-вывода.
