# Спецификация системы логирования для MetaExpert

**ID:** `SPEC-LOGGING`
**Статус:** Утверждено
**Версия:** 1.0
**Дата:** 2025-10-16

---

## 1. Обзор

Этот документ определяет полную спецификацию для модуля логирования (`logger`) проекта `MetaExpert`. Система логирования является критически важным компонентом для отладки, мониторинга и анализа работы торговых экспертов.

Спецификация основана на использовании библиотеки `structlog` для обеспечения структурированного, расширяемого и высокопроизводительного логирования.

### 1.1. Цели системы логирования

- **Информативность:** Логи должны содержать достаточно контекста для полного понимания произошедших событий.
- **Структурированность:** Поддержка вывода в формате JSON для упрощения автоматизированной обработки и анализа логов (например, в ELK Stack, Datadog, Splunk).
- **Производительность:** Минимальное влияние на производительность основного приложения, особенно в live-trading режиме.
- **Гибкость:** Возможность легкой настройки уровней, форматов и обработчиков (handlers) логов.
- **Разделение потоков:** Разделение общих логов, торговых операций и ошибок по разным файлам.

---

## 2. Основные принципы проектирования

- **Библиотека-первичность:** Конфигурация и использование логгера должны быть доступны как через API библиотеки, так и через CLI.
- **Контекстуализация:** `structlog` будет использоваться для автоматического добавления контекста к лог-сообщениям (например, `expert_name`, `trade_id`, `order_id`).
- **Асинхронная поддержка:** Система должна быть совместима с асинхронным кодом (`asyncio`) и поддерживать асинхронную запись в файлы для минимизации блокировок.
- **Отказоустойчивость:** Ошибки в самой системе логирования не должны приводить к падению основного приложения. При сбоях (например, невозможность записи в файл) система должна пытаться записать ошибку в резервный поток (например, stderr) и, при необходимости, переключаться на более простой режим работы (например, с асинхронного на синхронный). Все ошибки самого логгера должны попадать в отдельный файл `logging_errors.log`.

---

## 3. Архитектура модуля логирования

### 3.1. Файловая структура модуля

```
src/metaexpert/
└── logger/
    ├── __init__.py         # Фабрика для создания и конфигурации логгера
    ├── config.py           # Модели Pydantic для конфигурации логирования
    ├── processors.py       # Кастомные процессоры для structlog
    └── handlers.py         # Кастомные обработчики (например, для Telegram/Discord)
```

### 3.2. Основные компоненты

- **`MetaLogger` (фабрика):** Основная функция в `logger/__init__.py`, отвечающая за конфигурацию `structlog` и возвращающая готовый к использованию логгер.
- **Модели `Pydantic`:** В `logger/config.py` будут определены модели для декларативной конфигурации логгера, что позволит легко настраивать его из `pyproject.toml` или переменных окружения.
- **Цепочка процессоров `structlog`:** В `logger/processors.py` будет определена и использована стандартная цепочка процессоров, включающая:
  - `structlog.contextvars.merge_contextvars`: для интеграции с `contextvars`.
  - `structlog.processors.add_log_level`: добавление уровня лога.
  - `structlog.processors.StackInfoRenderer`: рендеринг стектрейса.
  - `structlog.dev.set_exc_info`: добавление информации об исключениях.
  - `structlog.processors.TimeStamper`: добавление временной метки (в формате ISO 8601 UTC).
  - Кастомные процессоры для добавления доменного контекста (`add_expert_context`, `add_trade_details`).
  - `structlog.processors.JSONRenderer`: финальный рендеринг в JSON (для файлов).
  - `structlog.dev.ConsoleRenderer`: цветной рендеринг для консоли.
- **Обработчики (Handlers):** Помимо стандартных `FileHandler` и `StreamHandler`, в `logger/handlers.py` могут быть добавлены обработчики для отправки уведомлений о критических ошибках (например, `TelegramHandler`).

### 3.3. Конфигурация

Конфигурация логирования будет управляться через `Pydantic`-модель и может быть переопределена на разных уровнях (приоритет по убыванию):

1. **Опции CLI:** Параметры, переданные при запуске через командную строку (например, `metaexpert run --log-level DEBUG`), имеют наивысший приоритет.
2. **Конструктор `MetaExpert`:** Параметры, явно указанные при создании экземпляра `expert` в файле стратегии (как в `template.py`), например, `expert = MetaExpert(log_level="INFO", ...)`.
3. **Переменные окружения:** Значения из `.env` файла или системных переменных (например, `METAEXPERT_LOG_LEVEL=WARNING`).
4. **Глобальная конфигурация:** Настройки из `pyproject.toml` (если будут реализованы).
5. **Значения по умолчанию:** Встроенные значения по умолчанию в коде библиотеки.

---

## 4. Функциональные требования

### 4.1. Уровни логирования

Система поддерживает стандартные уровни: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`.

- **`DEBUG`:** Подробная информация для отладки (например, содержимое API-запросов/ответов).
- **`INFO`:** Ключевые события жизненного цикла эксперта (старт, стоп, открытие/закрытие позиции).
- **`WARNING`:** Нештатные, но не критичные ситуации (например, большое проскальзывание, временная потеря соединения).
- **`ERROR`:** Ошибки, которые привели к сбою выполнения конкретной операции, но не всего приложения (например, не удалось разместить ордер).
- **`CRITICAL`:** Ошибки, приводящие к аварийному завершению работы эксперта.
- **`TRADE`:** Специализированный уровень для логирования исключительно торговых событий (создание, исполнение ордеров). Сообщения этого уровня направляются только в `trades.log`. Для его реализации будет использован `logging.addLevelName`, а для удобства вызова будет создан кастомный класс логгера-обертки с методом `.trade()`.

### 4.2. Форматы вывода

#### 4.2.1. Текстовый формат (для консоли)

Оптимизирован для человеческого восприятия, с цветовым выделением уровней.

```
2025-10-16 10:30:00 [INFO     ] Expert started     expert_name=MyEmaBot symbol=BTCUSDT
2025-10-16 10:31:00 [INFO     ] Position opened    action=BUY size=0.1 price=70000.0 order_id=123
2025-10-16 10:32:00 [ERROR    ] Order failed       reason="Insufficient funds" order_id=124
```

#### 4.2.2. JSON формат (для файлов и внешних систем)

Каждая запись — это отдельный JSON-объект, содержащий максимум контекста.

```json
{"event": "Position opened", "level": "info", "timestamp": "2025-10-16T10:31:00Z", "expert_name": "MyEmaBot", "symbol": "BTCUSDT", "action": "BUY", "size": 0.1, "price": 70000.0, "order_id": 123}
{"event": "Order failed", "level": "error", "timestamp": "2025-10-16T10:32:00Z", "expert_name": "MyEmaBot", "reason": "Insufficient funds", "order_id": 124}
```

### 4.3. Разделение лог-файлов

- **`expert.log`:** Основной лог-файл. Содержит все сообщения от `INFO` и выше.
- **`trades.log`:** Специализированный лог только для торговых операций (создание/исполнение/отмена ордеров, открытие/закрытие позиций). Записывается в формате **JSON Lines (JSONL)**, где каждая строка является валидным JSON-объектом.
- **`errors.log`:** Содержит только сообщения уровня `ERROR` и `CRITICAL` с полным стектрейсом.

### 4.4. Ротация логов

Для всех лог-файлов должна быть настроена автоматическая ротация по размеру (`RotatingFileHandler`).

- Максимальный размер файла: 10 MB (настраивается).
- Количество бэкап-файлов: 5 (настраивается).

### 4.5. Контекстуализация

`structlog` позволяет привязывать контекст к логгеру.

```python
# Привязка контекста на уровне эксперта
log = logger.bind(expert_name="MyEmaBot", symbol="BTCUSDT")

# Внутри торговой логики можно добавлять временный контекст
log.info("Processing order", order_id=order.id)
```

---

## 5. API и использование

### 5.1. Инициализация в `MetaExpert`

Логгер инициализируется внутри `MetaExpert.__init__` и доступен через `self.logger`.

```python
class MetaExpert:
    def __init__(self, log_level: str = "INFO", structured_logging: bool = False, ...):
        self.logger = MetaLogger(
            log_level=log_level,
            structured_logging=structured_logging,
            ...
        )
        self.logger.info("Expert initialized")
```

### 5.2. Использование в коде стратегии

Пользователь получает доступ к логгеру через экземпляр `expert`.

```python
@expert.on_bar
def my_strategy(rates):
    expert.logger.info("New bar received", open=rates.open, close=rates.close)
    if some_condition:
        expert.logger.warning("High volatility detected", volatility=0.5)

# Логирование торговой операции с использованием специального метода
expert.logger.trade("Position opened", side="BUY", size=0.1, price=70000.0)
```

---

## 6. Тестирование

- Модуль `logger` должен быть покрыт unit-тестами.
- Тесты должны проверять:
  - Корректность конфигурации логгера с разными параметрами.
  - Правильность форматов вывода (текстовый и JSON).
  - Корректность работы кастомных процессоров.
  - Правильное разделение записей по разным файлам (`trades.log`, `errors.log`).
- Покрытие кода тестами для модуля `logger` должно быть не менее 95%.

---

## 7. Документация

- Создать файл `docs/guides/logging.md`, описывающий:
  - Как настраивать логирование.
  - Разницу между форматами вывода.
  - Назначение разных лог-файлов.
  - Примеры добавления контекста в логи.
- Обновить `README.md` и `template.py` с примерами использования логгера.
