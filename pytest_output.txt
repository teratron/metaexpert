============================= test session starts =============================
platform win32 -- Python 3.12.10, pytest-8.4.2, pluggy-1.6.0
rootdir: D:\Projects\src\github.com\teratron\metaexpert-gemini
configfile: pyproject.toml
plugins: anyio-4.11.0, asyncio-1.2.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 0 items / 4 errors

=================================== ERRORS ====================================
_______________ ERROR collecting tests/cli/test_backtest_cmd.py _______________

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_backtest_cmd.py')
config = <_pytest.config.Config object at 0x000001FB7FAF0BF0>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
>           mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )

.venv\Lib\site-packages\_pytest\python.py:498: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_backtest_cmd.py')

    def import_path(
        path: str | os.PathLike[str],
        *,
        mode: str | ImportMode = ImportMode.prepend,
        root: Path,
        consider_namespace_packages: bool,
    ) -> ModuleType:
        """
        Import and return a module from the given path, which can be a file (a module) or
        a directory (a package).
    
        :param path:
            Path to the file to import.
    
        :param mode:
            Controls the underlying import mechanism that will be used:
    
            * ImportMode.prepend: the directory containing the module (or package, taking
              `__init__.py` files into account) will be put at the *start* of `sys.path` before
              being imported with `importlib.import_module`.
    
            * ImportMode.append: same as `prepend`, but the directory will be appended
              to the end of `sys.path`, if not already in `sys.path`.
    
            * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`
              to import the module, which avoids having to muck with `sys.path` at all. It effectively
              allows having same-named test modules in different places.
    
        :param root:
            Used as an anchor when mode == ImportMode.importlib to obtain
            a unique name for the module being imported so it can safely be stored
            into ``sys.modules``.
    
        :param consider_namespace_packages:
            If True, consider namespace packages when resolving module names.
    
        :raises ImportPathMismatchError:
            If after importing the given `path` and the module `__file__`
            are different. Only raised in `prepend` and `append` modes.
        """
        path = Path(path)
        mode = ImportMode(mode)
    
        if not path.exists():
            raise ImportError(path)
    
        if mode is ImportMode.importlib:
            # Try to import this module using the standard import mechanisms, but
            # without touching sys.path.
            try:
                pkg_root, module_name = resolve_pkg_root_and_module_name(
                    path, consider_namespace_packages=consider_namespace_packages
                )
            except CouldNotResolvePathError:
                pass
            else:
                # If the given module name is already in sys.modules, do not import it again.
                with contextlib.suppress(KeyError):
                    return sys.modules[module_name]
    
                mod = _import_module_using_spec(
                    module_name, path, pkg_root, insert_modules=False
                )
                if mod is not None:
                    return mod
    
            # Could not import the module with the current sys.path, so we fall back
            # to importing the file as a single module, not being a part of a package.
            module_name = module_name_from_path(path, root)
            with contextlib.suppress(KeyError):
                return sys.modules[module_name]
    
            mod = _import_module_using_spec(
                module_name, path, path.parent, insert_modules=True
            )
            if mod is None:
                raise ImportError(f"Can't find module {module_name} at location {path}")
            return mod
    
        try:
            pkg_root, module_name = resolve_pkg_root_and_module_name(
                path, consider_namespace_packages=consider_namespace_packages
            )
        except CouldNotResolvePathError:
            pkg_root, module_name = path.parent, path.stem
    
        # Change sys.path permanently: restoring it at the end of this function would cause surprising
        # problems because of delayed imports: for example, a conftest.py file imported by this function
        # might have local imports, which would fail at runtime if we restored sys.path.
        if mode is ImportMode.append:
            if str(pkg_root) not in sys.path:
                sys.path.append(str(pkg_root))
        elif mode is ImportMode.prepend:
            if str(pkg_root) != sys.path[0]:
                sys.path.insert(0, str(pkg_root))
        else:
            assert_never(mode)
    
>       importlib.import_module(module_name)

.venv\Lib\site-packages\_pytest\pathlib.py:587: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_backtest_cmd', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Oleg\AppData\Roaming\uv\python\cpython-3.12.10-windows-x86_64-none\Lib\importlib\__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_backtest_cmd', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_backtest_cmd'
import_ = <function _gcd_import at 0x000001FB7F1A80E0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_backtest_cmd'
import_ = <function _gcd_import at 0x000001FB7F1A80E0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='test_backtest_cmd', loader=<_pytest.assertion.rewrite.AssertionRewritingHook object at 0x000001FB0066CF20>, origin='D:\\Projects\\src\\github.com\\teratron\\metaexpert-gemini\\tests\\cli\\test_backtest_cmd.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.assertion.rewrite.AssertionRewritingHook object at 0x000001FB0066CF20>
module = <module 'test_backtest_cmd' from 'D:\\Projects\\src\\github.com\\teratron\\metaexpert-gemini\\tests\\cli\\test_backtest_cmd.py'>

    def exec_module(self, module: types.ModuleType) -> None:
        assert module.__spec__ is not None
        assert module.__spec__.origin is not None
        fn = Path(module.__spec__.origin)
        state = self.config.stash[assertstate_key]
    
        self._rewritten_names[module.__name__] = fn
    
        # The requested module looks like a test file, so rewrite it. This is
        # the most magical part of the process: load the source, rewrite the
        # asserts, and load the rewritten source. We also cache the rewritten
        # module code in a special pyc. We must be aware of the possibility of
        # concurrent pytest processes rewriting and loading pycs. To avoid
        # tricky race conditions, we maintain the following invariant: The
        # cached pyc is always a complete, valid pyc. Operations on it must be
        # atomic. POSIX's atomic rename comes in handy.
        write = not sys.dont_write_bytecode
        cache_dir = get_cache_dir(fn)
        if write:
            ok = try_makedirs(cache_dir)
            if not ok:
                write = False
                state.trace(f"read only directory: {cache_dir}")
    
        cache_name = fn.name[:-3] + PYC_TAIL
        pyc = cache_dir / cache_name
        # Notice that even if we're in a read-only directory, I'm going
        # to check for a cached pyc. This may not be optimal...
        co = _read_pyc(fn, pyc, state.trace)
        if co is None:
            state.trace(f"rewriting {fn!r}")
            source_stat, co = _rewrite_test(fn, self.config)
            if write:
                self._writing_pyc = True
                try:
                    _write_pyc(state, co, source_stat, pyc)
                finally:
                    self._writing_pyc = False
        else:
            state.trace(f"found cached rewritten pyc for {fn}")
>       exec(co, module.__dict__)

.venv\Lib\site-packages\_pytest\assertion\rewrite.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from typer.testing import CliRunner
    
>   from metaexpert.cli.main import app

tests\cli\test_backtest_cmd.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import typer
    
    from metaexpert.cli.backtest_cmd import backtest_cmd
>   from metaexpert.cli.list_cmd import list_cmd
E     File "D:\Projects\src\github.com\teratron\metaexpert-gemini\src\metaexpert\cli\list_cmd.py", line 23
E       else:  # Unix-like systems
E   SyntaxError: expected 'except' or 'finally' block

src\metaexpert\cli\main.py:4: SyntaxError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function pytest_make_collect_report.<locals>.collect at 0x000001FB0063BA60>
when = 'collect', reraise = (<class 'KeyboardInterrupt'>, <class 'SystemExit'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def collect() -> list[Item | Collector]:
        # Before collecting, if this is a Directory, load the conftests.
        # If a conftest import fails to load, it is considered a collection
        # error of the Directory collector. This is why it's done inside of the
        # CallInfo wrapper.
        #
        # Note: initial conftests are loaded early, not here.
        if isinstance(collector, Directory):
            collector.config.pluginmanager._loadconftestmodules(
                collector.path,
                collector.config.getoption("importmode"),
                rootpath=collector.config.rootpath,
                consider_namespace_packages=collector.config.getini(
                    "consider_namespace_packages"
                ),
            )
    
>       return list(collector.collect())
                    ^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_backtest_cmd.py>

    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:
>       self._register_setup_module_fixture()

.venv\Lib\site-packages\_pytest\python.py:554: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_backtest_cmd.py>

    def _register_setup_module_fixture(self) -> None:
        """Register an autouse, module-scoped fixture for the collected module object
        that invokes setUpModule/tearDownModule if either or both are available.
    
        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
        other fixtures (#517).
        """
        setup_module = _get_first_non_fixture_func(
>           self.obj, ("setUpModule", "setup_module")
            ^^^^^^^^
        )

.venv\Lib\site-packages\_pytest\python.py:567: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_backtest_cmd.py>

    @property
    def obj(self):
        """Underlying Python object."""
        obj = getattr(self, "_obj", None)
        if obj is None:
>           self._obj = obj = self._getobj()
                              ^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\python.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_backtest_cmd.py>

    def _getobj(self):
>       return importtestmodule(self.path, self.config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\python.py:551: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_backtest_cmd.py')
config = <_pytest.config.Config object at 0x000001FB7FAF0BF0>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
            mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )
        except SyntaxError as e:
>           raise nodes.Collector.CollectError(
                ExceptionInfo.from_current().getrepr(style="short")
            ) from e
E           _pytest.nodes.Collector.CollectError: .venv\Lib\site-packages\_pytest\python.py:498: in importtestmodule
E               mod = import_path(
E           .venv\Lib\site-packages\_pytest\pathlib.py:587: in import_path
E               importlib.import_module(module_name)
E           C:\Users\Oleg\AppData\Roaming\uv\python\cpython-3.12.10-windows-x86_64-none\Lib\importlib\__init__.py:90: in import_module
E               return _bootstrap._gcd_import(name[level:], package, level)
E                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           <frozen importlib._bootstrap>:1387: in _gcd_import
E               ???
E           <frozen importlib._bootstrap>:1360: in _find_and_load
E               ???
E           <frozen importlib._bootstrap>:1331: in _find_and_load_unlocked
E               ???
E           <frozen importlib._bootstrap>:935: in _load_unlocked
E               ???
E           .venv\Lib\site-packages\_pytest\assertion\rewrite.py:186: in exec_module
E               exec(co, module.__dict__)
E           tests\cli\test_backtest_cmd.py:3: in <module>
E               from metaexpert.cli.main import app
E           src\metaexpert\cli\main.py:4: in <module>
E               from metaexpert.cli.list_cmd import list_cmd
E           E     File "D:\Projects\src\github.com\teratron\metaexpert-gemini\src\metaexpert\cli\list_cmd.py", line 23
E           E       else:  # Unix-like systems
E           E   SyntaxError: expected 'except' or 'finally' block

.venv\Lib\site-packages\_pytest\python.py:505: CollectError
________________ ERROR collecting tests/cli/test_lifecycle.py _________________

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_lifecycle.py')
config = <_pytest.config.Config object at 0x000001FB7FAF0BF0>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
>           mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )

.venv\Lib\site-packages\_pytest\python.py:498: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_lifecycle.py')

    def import_path(
        path: str | os.PathLike[str],
        *,
        mode: str | ImportMode = ImportMode.prepend,
        root: Path,
        consider_namespace_packages: bool,
    ) -> ModuleType:
        """
        Import and return a module from the given path, which can be a file (a module) or
        a directory (a package).
    
        :param path:
            Path to the file to import.
    
        :param mode:
            Controls the underlying import mechanism that will be used:
    
            * ImportMode.prepend: the directory containing the module (or package, taking
              `__init__.py` files into account) will be put at the *start* of `sys.path` before
              being imported with `importlib.import_module`.
    
            * ImportMode.append: same as `prepend`, but the directory will be appended
              to the end of `sys.path`, if not already in `sys.path`.
    
            * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`
              to import the module, which avoids having to muck with `sys.path` at all. It effectively
              allows having same-named test modules in different places.
    
        :param root:
            Used as an anchor when mode == ImportMode.importlib to obtain
            a unique name for the module being imported so it can safely be stored
            into ``sys.modules``.
    
        :param consider_namespace_packages:
            If True, consider namespace packages when resolving module names.
    
        :raises ImportPathMismatchError:
            If after importing the given `path` and the module `__file__`
            are different. Only raised in `prepend` and `append` modes.
        """
        path = Path(path)
        mode = ImportMode(mode)
    
        if not path.exists():
            raise ImportError(path)
    
        if mode is ImportMode.importlib:
            # Try to import this module using the standard import mechanisms, but
            # without touching sys.path.
            try:
                pkg_root, module_name = resolve_pkg_root_and_module_name(
                    path, consider_namespace_packages=consider_namespace_packages
                )
            except CouldNotResolvePathError:
                pass
            else:
                # If the given module name is already in sys.modules, do not import it again.
                with contextlib.suppress(KeyError):
                    return sys.modules[module_name]
    
                mod = _import_module_using_spec(
                    module_name, path, pkg_root, insert_modules=False
                )
                if mod is not None:
                    return mod
    
            # Could not import the module with the current sys.path, so we fall back
            # to importing the file as a single module, not being a part of a package.
            module_name = module_name_from_path(path, root)
            with contextlib.suppress(KeyError):
                return sys.modules[module_name]
    
            mod = _import_module_using_spec(
                module_name, path, path.parent, insert_modules=True
            )
            if mod is None:
                raise ImportError(f"Can't find module {module_name} at location {path}")
            return mod
    
        try:
            pkg_root, module_name = resolve_pkg_root_and_module_name(
                path, consider_namespace_packages=consider_namespace_packages
            )
        except CouldNotResolvePathError:
            pkg_root, module_name = path.parent, path.stem
    
        # Change sys.path permanently: restoring it at the end of this function would cause surprising
        # problems because of delayed imports: for example, a conftest.py file imported by this function
        # might have local imports, which would fail at runtime if we restored sys.path.
        if mode is ImportMode.append:
            if str(pkg_root) not in sys.path:
                sys.path.append(str(pkg_root))
        elif mode is ImportMode.prepend:
            if str(pkg_root) != sys.path[0]:
                sys.path.insert(0, str(pkg_root))
        else:
            assert_never(mode)
    
>       importlib.import_module(module_name)

.venv\Lib\site-packages\_pytest\pathlib.py:587: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_lifecycle', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Oleg\AppData\Roaming\uv\python\cpython-3.12.10-windows-x86_64-none\Lib\importlib\__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_lifecycle', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_lifecycle', import_ = <function _gcd_import at 0x000001FB7F1A80E0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_lifecycle', import_ = <function _gcd_import at 0x000001FB7F1A80E0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='test_lifecycle', loader=<_pytest.assertion.rewrite.AssertionRewritingHook object at 0x000001FB0066CF20>, origin='D:\\Projects\\src\\github.com\\teratron\\metaexpert-gemini\\tests\\cli\\test_lifecycle.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.assertion.rewrite.AssertionRewritingHook object at 0x000001FB0066CF20>
module = <module 'test_lifecycle' from 'D:\\Projects\\src\\github.com\\teratron\\metaexpert-gemini\\tests\\cli\\test_lifecycle.py'>

    def exec_module(self, module: types.ModuleType) -> None:
        assert module.__spec__ is not None
        assert module.__spec__.origin is not None
        fn = Path(module.__spec__.origin)
        state = self.config.stash[assertstate_key]
    
        self._rewritten_names[module.__name__] = fn
    
        # The requested module looks like a test file, so rewrite it. This is
        # the most magical part of the process: load the source, rewrite the
        # asserts, and load the rewritten source. We also cache the rewritten
        # module code in a special pyc. We must be aware of the possibility of
        # concurrent pytest processes rewriting and loading pycs. To avoid
        # tricky race conditions, we maintain the following invariant: The
        # cached pyc is always a complete, valid pyc. Operations on it must be
        # atomic. POSIX's atomic rename comes in handy.
        write = not sys.dont_write_bytecode
        cache_dir = get_cache_dir(fn)
        if write:
            ok = try_makedirs(cache_dir)
            if not ok:
                write = False
                state.trace(f"read only directory: {cache_dir}")
    
        cache_name = fn.name[:-3] + PYC_TAIL
        pyc = cache_dir / cache_name
        # Notice that even if we're in a read-only directory, I'm going
        # to check for a cached pyc. This may not be optimal...
        co = _read_pyc(fn, pyc, state.trace)
        if co is None:
            state.trace(f"rewriting {fn!r}")
            source_stat, co = _rewrite_test(fn, self.config)
            if write:
                self._writing_pyc = True
                try:
                    _write_pyc(state, co, source_stat, pyc)
                finally:
                    self._writing_pyc = False
        else:
            state.trace(f"found cached rewritten pyc for {fn}")
>       exec(co, module.__dict__)

.venv\Lib\site-packages\_pytest\assertion\rewrite.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import os
    import subprocess
    import sys
    import time
    from pathlib import Path
    
    from typer.testing import CliRunner
    
>   from metaexpert.cli.main import app

tests\cli\test_lifecycle.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import typer
    
    from metaexpert.cli.backtest_cmd import backtest_cmd
>   from metaexpert.cli.list_cmd import list_cmd
E     File "D:\Projects\src\github.com\teratron\metaexpert-gemini\src\metaexpert\cli\list_cmd.py", line 23
E       else:  # Unix-like systems
E   SyntaxError: expected 'except' or 'finally' block

src\metaexpert\cli\main.py:4: SyntaxError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function pytest_make_collect_report.<locals>.collect at 0x000001FB02BD40E0>
when = 'collect', reraise = (<class 'KeyboardInterrupt'>, <class 'SystemExit'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def collect() -> list[Item | Collector]:
        # Before collecting, if this is a Directory, load the conftests.
        # If a conftest import fails to load, it is considered a collection
        # error of the Directory collector. This is why it's done inside of the
        # CallInfo wrapper.
        #
        # Note: initial conftests are loaded early, not here.
        if isinstance(collector, Directory):
            collector.config.pluginmanager._loadconftestmodules(
                collector.path,
                collector.config.getoption("importmode"),
                rootpath=collector.config.rootpath,
                consider_namespace_packages=collector.config.getini(
                    "consider_namespace_packages"
                ),
            )
    
>       return list(collector.collect())
                    ^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_lifecycle.py>

    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:
>       self._register_setup_module_fixture()

.venv\Lib\site-packages\_pytest\python.py:554: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_lifecycle.py>

    def _register_setup_module_fixture(self) -> None:
        """Register an autouse, module-scoped fixture for the collected module object
        that invokes setUpModule/tearDownModule if either or both are available.
    
        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
        other fixtures (#517).
        """
        setup_module = _get_first_non_fixture_func(
>           self.obj, ("setUpModule", "setup_module")
            ^^^^^^^^
        )

.venv\Lib\site-packages\_pytest\python.py:567: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_lifecycle.py>

    @property
    def obj(self):
        """Underlying Python object."""
        obj = getattr(self, "_obj", None)
        if obj is None:
>           self._obj = obj = self._getobj()
                              ^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\python.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_lifecycle.py>

    def _getobj(self):
>       return importtestmodule(self.path, self.config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\python.py:551: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_lifecycle.py')
config = <_pytest.config.Config object at 0x000001FB7FAF0BF0>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
            mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )
        except SyntaxError as e:
>           raise nodes.Collector.CollectError(
                ExceptionInfo.from_current().getrepr(style="short")
            ) from e
E           _pytest.nodes.Collector.CollectError: .venv\Lib\site-packages\_pytest\python.py:498: in importtestmodule
E               mod = import_path(
E           .venv\Lib\site-packages\_pytest\pathlib.py:587: in import_path
E               importlib.import_module(module_name)
E           C:\Users\Oleg\AppData\Roaming\uv\python\cpython-3.12.10-windows-x86_64-none\Lib\importlib\__init__.py:90: in import_module
E               return _bootstrap._gcd_import(name[level:], package, level)
E                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           <frozen importlib._bootstrap>:1387: in _gcd_import
E               ???
E           <frozen importlib._bootstrap>:1360: in _find_and_load
E               ???
E           <frozen importlib._bootstrap>:1331: in _find_and_load_unlocked
E               ???
E           <frozen importlib._bootstrap>:935: in _load_unlocked
E               ???
E           .venv\Lib\site-packages\_pytest\assertion\rewrite.py:186: in exec_module
E               exec(co, module.__dict__)
E           tests\cli\test_lifecycle.py:9: in <module>
E               from metaexpert.cli.main import app
E           src\metaexpert\cli\main.py:4: in <module>
E               from metaexpert.cli.list_cmd import list_cmd
E           E     File "D:\Projects\src\github.com\teratron\metaexpert-gemini\src\metaexpert\cli\list_cmd.py", line 23
E           E       else:  # Unix-like systems
E           E   SyntaxError: expected 'except' or 'finally' block

.venv\Lib\site-packages\_pytest\python.py:505: CollectError
_________________ ERROR collecting tests/cli/test_new_cmd.py __________________

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_new_cmd.py')
config = <_pytest.config.Config object at 0x000001FB7FAF0BF0>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
>           mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )

.venv\Lib\site-packages\_pytest\python.py:498: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_new_cmd.py')

    def import_path(
        path: str | os.PathLike[str],
        *,
        mode: str | ImportMode = ImportMode.prepend,
        root: Path,
        consider_namespace_packages: bool,
    ) -> ModuleType:
        """
        Import and return a module from the given path, which can be a file (a module) or
        a directory (a package).
    
        :param path:
            Path to the file to import.
    
        :param mode:
            Controls the underlying import mechanism that will be used:
    
            * ImportMode.prepend: the directory containing the module (or package, taking
              `__init__.py` files into account) will be put at the *start* of `sys.path` before
              being imported with `importlib.import_module`.
    
            * ImportMode.append: same as `prepend`, but the directory will be appended
              to the end of `sys.path`, if not already in `sys.path`.
    
            * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`
              to import the module, which avoids having to muck with `sys.path` at all. It effectively
              allows having same-named test modules in different places.
    
        :param root:
            Used as an anchor when mode == ImportMode.importlib to obtain
            a unique name for the module being imported so it can safely be stored
            into ``sys.modules``.
    
        :param consider_namespace_packages:
            If True, consider namespace packages when resolving module names.
    
        :raises ImportPathMismatchError:
            If after importing the given `path` and the module `__file__`
            are different. Only raised in `prepend` and `append` modes.
        """
        path = Path(path)
        mode = ImportMode(mode)
    
        if not path.exists():
            raise ImportError(path)
    
        if mode is ImportMode.importlib:
            # Try to import this module using the standard import mechanisms, but
            # without touching sys.path.
            try:
                pkg_root, module_name = resolve_pkg_root_and_module_name(
                    path, consider_namespace_packages=consider_namespace_packages
                )
            except CouldNotResolvePathError:
                pass
            else:
                # If the given module name is already in sys.modules, do not import it again.
                with contextlib.suppress(KeyError):
                    return sys.modules[module_name]
    
                mod = _import_module_using_spec(
                    module_name, path, pkg_root, insert_modules=False
                )
                if mod is not None:
                    return mod
    
            # Could not import the module with the current sys.path, so we fall back
            # to importing the file as a single module, not being a part of a package.
            module_name = module_name_from_path(path, root)
            with contextlib.suppress(KeyError):
                return sys.modules[module_name]
    
            mod = _import_module_using_spec(
                module_name, path, path.parent, insert_modules=True
            )
            if mod is None:
                raise ImportError(f"Can't find module {module_name} at location {path}")
            return mod
    
        try:
            pkg_root, module_name = resolve_pkg_root_and_module_name(
                path, consider_namespace_packages=consider_namespace_packages
            )
        except CouldNotResolvePathError:
            pkg_root, module_name = path.parent, path.stem
    
        # Change sys.path permanently: restoring it at the end of this function would cause surprising
        # problems because of delayed imports: for example, a conftest.py file imported by this function
        # might have local imports, which would fail at runtime if we restored sys.path.
        if mode is ImportMode.append:
            if str(pkg_root) not in sys.path:
                sys.path.append(str(pkg_root))
        elif mode is ImportMode.prepend:
            if str(pkg_root) != sys.path[0]:
                sys.path.insert(0, str(pkg_root))
        else:
            assert_never(mode)
    
>       importlib.import_module(module_name)

.venv\Lib\site-packages\_pytest\pathlib.py:587: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_new_cmd', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Oleg\AppData\Roaming\uv\python\cpython-3.12.10-windows-x86_64-none\Lib\importlib\__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_new_cmd', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_new_cmd', import_ = <function _gcd_import at 0x000001FB7F1A80E0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_new_cmd', import_ = <function _gcd_import at 0x000001FB7F1A80E0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='test_new_cmd', loader=<_pytest.assertion.rewrite.AssertionRewritingHook object at 0x000001FB0066CF20>, origin='D:\\Projects\\src\\github.com\\teratron\\metaexpert-gemini\\tests\\cli\\test_new_cmd.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.assertion.rewrite.AssertionRewritingHook object at 0x000001FB0066CF20>
module = <module 'test_new_cmd' from 'D:\\Projects\\src\\github.com\\teratron\\metaexpert-gemini\\tests\\cli\\test_new_cmd.py'>

    def exec_module(self, module: types.ModuleType) -> None:
        assert module.__spec__ is not None
        assert module.__spec__.origin is not None
        fn = Path(module.__spec__.origin)
        state = self.config.stash[assertstate_key]
    
        self._rewritten_names[module.__name__] = fn
    
        # The requested module looks like a test file, so rewrite it. This is
        # the most magical part of the process: load the source, rewrite the
        # asserts, and load the rewritten source. We also cache the rewritten
        # module code in a special pyc. We must be aware of the possibility of
        # concurrent pytest processes rewriting and loading pycs. To avoid
        # tricky race conditions, we maintain the following invariant: The
        # cached pyc is always a complete, valid pyc. Operations on it must be
        # atomic. POSIX's atomic rename comes in handy.
        write = not sys.dont_write_bytecode
        cache_dir = get_cache_dir(fn)
        if write:
            ok = try_makedirs(cache_dir)
            if not ok:
                write = False
                state.trace(f"read only directory: {cache_dir}")
    
        cache_name = fn.name[:-3] + PYC_TAIL
        pyc = cache_dir / cache_name
        # Notice that even if we're in a read-only directory, I'm going
        # to check for a cached pyc. This may not be optimal...
        co = _read_pyc(fn, pyc, state.trace)
        if co is None:
            state.trace(f"rewriting {fn!r}")
            source_stat, co = _rewrite_test(fn, self.config)
            if write:
                self._writing_pyc = True
                try:
                    _write_pyc(state, co, source_stat, pyc)
                finally:
                    self._writing_pyc = False
        else:
            state.trace(f"found cached rewritten pyc for {fn}")
>       exec(co, module.__dict__)

.venv\Lib\site-packages\_pytest\assertion\rewrite.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from pathlib import Path
    
    from typer.testing import CliRunner
    
>   from metaexpert.cli.main import app

tests\cli\test_new_cmd.py:5: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import typer
    
    from metaexpert.cli.backtest_cmd import backtest_cmd
>   from metaexpert.cli.list_cmd import list_cmd
E     File "D:\Projects\src\github.com\teratron\metaexpert-gemini\src\metaexpert\cli\list_cmd.py", line 23
E       else:  # Unix-like systems
E   SyntaxError: expected 'except' or 'finally' block

src\metaexpert\cli\main.py:4: SyntaxError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function pytest_make_collect_report.<locals>.collect at 0x000001FB02B7F560>
when = 'collect', reraise = (<class 'KeyboardInterrupt'>, <class 'SystemExit'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def collect() -> list[Item | Collector]:
        # Before collecting, if this is a Directory, load the conftests.
        # If a conftest import fails to load, it is considered a collection
        # error of the Directory collector. This is why it's done inside of the
        # CallInfo wrapper.
        #
        # Note: initial conftests are loaded early, not here.
        if isinstance(collector, Directory):
            collector.config.pluginmanager._loadconftestmodules(
                collector.path,
                collector.config.getoption("importmode"),
                rootpath=collector.config.rootpath,
                consider_namespace_packages=collector.config.getini(
                    "consider_namespace_packages"
                ),
            )
    
>       return list(collector.collect())
                    ^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_new_cmd.py>

    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:
>       self._register_setup_module_fixture()

.venv\Lib\site-packages\_pytest\python.py:554: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_new_cmd.py>

    def _register_setup_module_fixture(self) -> None:
        """Register an autouse, module-scoped fixture for the collected module object
        that invokes setUpModule/tearDownModule if either or both are available.
    
        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
        other fixtures (#517).
        """
        setup_module = _get_first_non_fixture_func(
>           self.obj, ("setUpModule", "setup_module")
            ^^^^^^^^
        )

.venv\Lib\site-packages\_pytest\python.py:567: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_new_cmd.py>

    @property
    def obj(self):
        """Underlying Python object."""
        obj = getattr(self, "_obj", None)
        if obj is None:
>           self._obj = obj = self._getobj()
                              ^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\python.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_new_cmd.py>

    def _getobj(self):
>       return importtestmodule(self.path, self.config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\python.py:551: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_new_cmd.py')
config = <_pytest.config.Config object at 0x000001FB7FAF0BF0>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
            mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )
        except SyntaxError as e:
>           raise nodes.Collector.CollectError(
                ExceptionInfo.from_current().getrepr(style="short")
            ) from e
E           _pytest.nodes.Collector.CollectError: .venv\Lib\site-packages\_pytest\python.py:498: in importtestmodule
E               mod = import_path(
E           .venv\Lib\site-packages\_pytest\pathlib.py:587: in import_path
E               importlib.import_module(module_name)
E           C:\Users\Oleg\AppData\Roaming\uv\python\cpython-3.12.10-windows-x86_64-none\Lib\importlib\__init__.py:90: in import_module
E               return _bootstrap._gcd_import(name[level:], package, level)
E                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           <frozen importlib._bootstrap>:1387: in _gcd_import
E               ???
E           <frozen importlib._bootstrap>:1360: in _find_and_load
E               ???
E           <frozen importlib._bootstrap>:1331: in _find_and_load_unlocked
E               ???
E           <frozen importlib._bootstrap>:935: in _load_unlocked
E               ???
E           .venv\Lib\site-packages\_pytest\assertion\rewrite.py:186: in exec_module
E               exec(co, module.__dict__)
E           tests\cli\test_new_cmd.py:5: in <module>
E               from metaexpert.cli.main import app
E           src\metaexpert\cli\main.py:4: in <module>
E               from metaexpert.cli.list_cmd import list_cmd
E           E     File "D:\Projects\src\github.com\teratron\metaexpert-gemini\src\metaexpert\cli\list_cmd.py", line 23
E           E       else:  # Unix-like systems
E           E   SyntaxError: expected 'except' or 'finally' block

.venv\Lib\site-packages\_pytest\python.py:505: CollectError
_________________ ERROR collecting tests/cli/test_run_cmd.py __________________

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_run_cmd.py')
config = <_pytest.config.Config object at 0x000001FB7FAF0BF0>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
>           mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )

.venv\Lib\site-packages\_pytest\python.py:498: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_run_cmd.py')

    def import_path(
        path: str | os.PathLike[str],
        *,
        mode: str | ImportMode = ImportMode.prepend,
        root: Path,
        consider_namespace_packages: bool,
    ) -> ModuleType:
        """
        Import and return a module from the given path, which can be a file (a module) or
        a directory (a package).
    
        :param path:
            Path to the file to import.
    
        :param mode:
            Controls the underlying import mechanism that will be used:
    
            * ImportMode.prepend: the directory containing the module (or package, taking
              `__init__.py` files into account) will be put at the *start* of `sys.path` before
              being imported with `importlib.import_module`.
    
            * ImportMode.append: same as `prepend`, but the directory will be appended
              to the end of `sys.path`, if not already in `sys.path`.
    
            * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`
              to import the module, which avoids having to muck with `sys.path` at all. It effectively
              allows having same-named test modules in different places.
    
        :param root:
            Used as an anchor when mode == ImportMode.importlib to obtain
            a unique name for the module being imported so it can safely be stored
            into ``sys.modules``.
    
        :param consider_namespace_packages:
            If True, consider namespace packages when resolving module names.
    
        :raises ImportPathMismatchError:
            If after importing the given `path` and the module `__file__`
            are different. Only raised in `prepend` and `append` modes.
        """
        path = Path(path)
        mode = ImportMode(mode)
    
        if not path.exists():
            raise ImportError(path)
    
        if mode is ImportMode.importlib:
            # Try to import this module using the standard import mechanisms, but
            # without touching sys.path.
            try:
                pkg_root, module_name = resolve_pkg_root_and_module_name(
                    path, consider_namespace_packages=consider_namespace_packages
                )
            except CouldNotResolvePathError:
                pass
            else:
                # If the given module name is already in sys.modules, do not import it again.
                with contextlib.suppress(KeyError):
                    return sys.modules[module_name]
    
                mod = _import_module_using_spec(
                    module_name, path, pkg_root, insert_modules=False
                )
                if mod is not None:
                    return mod
    
            # Could not import the module with the current sys.path, so we fall back
            # to importing the file as a single module, not being a part of a package.
            module_name = module_name_from_path(path, root)
            with contextlib.suppress(KeyError):
                return sys.modules[module_name]
    
            mod = _import_module_using_spec(
                module_name, path, path.parent, insert_modules=True
            )
            if mod is None:
                raise ImportError(f"Can't find module {module_name} at location {path}")
            return mod
    
        try:
            pkg_root, module_name = resolve_pkg_root_and_module_name(
                path, consider_namespace_packages=consider_namespace_packages
            )
        except CouldNotResolvePathError:
            pkg_root, module_name = path.parent, path.stem
    
        # Change sys.path permanently: restoring it at the end of this function would cause surprising
        # problems because of delayed imports: for example, a conftest.py file imported by this function
        # might have local imports, which would fail at runtime if we restored sys.path.
        if mode is ImportMode.append:
            if str(pkg_root) not in sys.path:
                sys.path.append(str(pkg_root))
        elif mode is ImportMode.prepend:
            if str(pkg_root) != sys.path[0]:
                sys.path.insert(0, str(pkg_root))
        else:
            assert_never(mode)
    
>       importlib.import_module(module_name)

.venv\Lib\site-packages\_pytest\pathlib.py:587: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_run_cmd', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Oleg\AppData\Roaming\uv\python\cpython-3.12.10-windows-x86_64-none\Lib\importlib\__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_run_cmd', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_run_cmd', import_ = <function _gcd_import at 0x000001FB7F1A80E0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'test_run_cmd', import_ = <function _gcd_import at 0x000001FB7F1A80E0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='test_run_cmd', loader=<_pytest.assertion.rewrite.AssertionRewritingHook object at 0x000001FB0066CF20>, origin='D:\\Projects\\src\\github.com\\teratron\\metaexpert-gemini\\tests\\cli\\test_run_cmd.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.assertion.rewrite.AssertionRewritingHook object at 0x000001FB0066CF20>
module = <module 'test_run_cmd' from 'D:\\Projects\\src\\github.com\\teratron\\metaexpert-gemini\\tests\\cli\\test_run_cmd.py'>

    def exec_module(self, module: types.ModuleType) -> None:
        assert module.__spec__ is not None
        assert module.__spec__.origin is not None
        fn = Path(module.__spec__.origin)
        state = self.config.stash[assertstate_key]
    
        self._rewritten_names[module.__name__] = fn
    
        # The requested module looks like a test file, so rewrite it. This is
        # the most magical part of the process: load the source, rewrite the
        # asserts, and load the rewritten source. We also cache the rewritten
        # module code in a special pyc. We must be aware of the possibility of
        # concurrent pytest processes rewriting and loading pycs. To avoid
        # tricky race conditions, we maintain the following invariant: The
        # cached pyc is always a complete, valid pyc. Operations on it must be
        # atomic. POSIX's atomic rename comes in handy.
        write = not sys.dont_write_bytecode
        cache_dir = get_cache_dir(fn)
        if write:
            ok = try_makedirs(cache_dir)
            if not ok:
                write = False
                state.trace(f"read only directory: {cache_dir}")
    
        cache_name = fn.name[:-3] + PYC_TAIL
        pyc = cache_dir / cache_name
        # Notice that even if we're in a read-only directory, I'm going
        # to check for a cached pyc. This may not be optimal...
        co = _read_pyc(fn, pyc, state.trace)
        if co is None:
            state.trace(f"rewriting {fn!r}")
            source_stat, co = _rewrite_test(fn, self.config)
            if write:
                self._writing_pyc = True
                try:
                    _write_pyc(state, co, source_stat, pyc)
                finally:
                    self._writing_pyc = False
        else:
            state.trace(f"found cached rewritten pyc for {fn}")
>       exec(co, module.__dict__)

.venv\Lib\site-packages\_pytest\assertion\rewrite.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import os
    import time
    from pathlib import Path
    
    from typer.testing import CliRunner
    
>   from metaexpert.cli.main import app

tests\cli\test_run_cmd.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import typer
    
    from metaexpert.cli.backtest_cmd import backtest_cmd
>   from metaexpert.cli.list_cmd import list_cmd
E     File "D:\Projects\src\github.com\teratron\metaexpert-gemini\src\metaexpert\cli\list_cmd.py", line 23
E       else:  # Unix-like systems
E   SyntaxError: expected 'except' or 'finally' block

src\metaexpert\cli\main.py:4: SyntaxError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function pytest_make_collect_report.<locals>.collect at 0x000001FB02BD5E40>
when = 'collect', reraise = (<class 'KeyboardInterrupt'>, <class 'SystemExit'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def collect() -> list[Item | Collector]:
        # Before collecting, if this is a Directory, load the conftests.
        # If a conftest import fails to load, it is considered a collection
        # error of the Directory collector. This is why it's done inside of the
        # CallInfo wrapper.
        #
        # Note: initial conftests are loaded early, not here.
        if isinstance(collector, Directory):
            collector.config.pluginmanager._loadconftestmodules(
                collector.path,
                collector.config.getoption("importmode"),
                rootpath=collector.config.rootpath,
                consider_namespace_packages=collector.config.getini(
                    "consider_namespace_packages"
                ),
            )
    
>       return list(collector.collect())
                    ^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_run_cmd.py>

    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:
>       self._register_setup_module_fixture()

.venv\Lib\site-packages\_pytest\python.py:554: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_run_cmd.py>

    def _register_setup_module_fixture(self) -> None:
        """Register an autouse, module-scoped fixture for the collected module object
        that invokes setUpModule/tearDownModule if either or both are available.
    
        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
        other fixtures (#517).
        """
        setup_module = _get_first_non_fixture_func(
>           self.obj, ("setUpModule", "setup_module")
            ^^^^^^^^
        )

.venv\Lib\site-packages\_pytest\python.py:567: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_run_cmd.py>

    @property
    def obj(self):
        """Underlying Python object."""
        obj = getattr(self, "_obj", None)
        if obj is None:
>           self._obj = obj = self._getobj()
                              ^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\python.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Module test_run_cmd.py>

    def _getobj(self):
>       return importtestmodule(self.path, self.config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\_pytest\python.py:551: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = WindowsPath('D:/Projects/src/github.com/teratron/metaexpert-gemini/tests/cli/test_run_cmd.py')
config = <_pytest.config.Config object at 0x000001FB7FAF0BF0>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
            mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )
        except SyntaxError as e:
>           raise nodes.Collector.CollectError(
                ExceptionInfo.from_current().getrepr(style="short")
            ) from e
E           _pytest.nodes.Collector.CollectError: .venv\Lib\site-packages\_pytest\python.py:498: in importtestmodule
E               mod = import_path(
E           .venv\Lib\site-packages\_pytest\pathlib.py:587: in import_path
E               importlib.import_module(module_name)
E           C:\Users\Oleg\AppData\Roaming\uv\python\cpython-3.12.10-windows-x86_64-none\Lib\importlib\__init__.py:90: in import_module
E               return _bootstrap._gcd_import(name[level:], package, level)
E                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           <frozen importlib._bootstrap>:1387: in _gcd_import
E               ???
E           <frozen importlib._bootstrap>:1360: in _find_and_load
E               ???
E           <frozen importlib._bootstrap>:1331: in _find_and_load_unlocked
E               ???
E           <frozen importlib._bootstrap>:935: in _load_unlocked
E               ???
E           .venv\Lib\site-packages\_pytest\assertion\rewrite.py:186: in exec_module
E               exec(co, module.__dict__)
E           tests\cli\test_run_cmd.py:7: in <module>
E               from metaexpert.cli.main import app
E           src\metaexpert\cli\main.py:4: in <module>
E               from metaexpert.cli.list_cmd import list_cmd
E           E     File "D:\Projects\src\github.com\teratron\metaexpert-gemini\src\metaexpert\cli\list_cmd.py", line 23
E           E       else:  # Unix-like systems
E           E   SyntaxError: expected 'except' or 'finally' block

.venv\Lib\site-packages\_pytest\python.py:505: CollectError
=========================== short test summary info ===========================
ERROR tests/cli/test_backtest_cmd.py - _pytest.nodes.Collector.CollectError: ...
ERROR tests/cli/test_lifecycle.py - _pytest.nodes.Collector.CollectError: .ve...
ERROR tests/cli/test_new_cmd.py - _pytest.nodes.Collector.CollectError: .venv...
ERROR tests/cli/test_run_cmd.py - _pytest.nodes.Collector.CollectError: .venv...
!!!!!!!!!!!!!!!!!!! Interrupted: 4 errors during collection !!!!!!!!!!!!!!!!!!!
============================== 4 errors in 1.26s ==============================
